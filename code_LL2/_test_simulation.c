/////////////////////////////////////////////////////////////////////////////
//
//  _test_simulation.c
//
// Created on: 2024.03.20
// Author: Gabriel Aguirre Ollinger
//
/////////////////////////////////////////////////////////////////////////////

#include "_test_simulation.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// TEST SCRIPT - SIMULATION - GAO
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
test_simulation() {

	/////////////////////////////////////////////////////////////////////////////////////
	// TRAJECTORY VARIABLES:
	/////////////////////////////////////////////////////////////////////////////////////

	const int DT_SIM_MSEC = 5;

	// Integrator time step:
	double dt_k = (double)DT_SIM_MSEC/1000.0; // integrator step (initial)

	// Admittance model state:
	double z_in[2*N_COORD_EXT] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}; // internal state

	// Reference position and velocity:
	double    p_ref[N_COORD_2D] = {0.0, 0.0};
	double dt_p_ref[N_COORD_2D] = {0.0, 0.0};

	// Cycle phase and instantaneous frequency:
	double    phi_ref = 0.0;
	double dt_phi_ref = 0.0;

	// Trajectory path tangent vector:
	double u_t_ref[N_COORD_2D] = {0.0, 0.0};

	/////////////////////////////////////////////////////////////////////////////////////
	// Dynamic system (ODE) set-up: inputs, parameters, etc.
	/////////////////////////////////////////////////////////////////////////////////////

	// ode_param_struct ode_params;
	// ode_params.ORD = 4; // use only with order 4 solver

	/////////////////////////////////////////////////////////////////////////////////////
	// COPY TRAJECTORY PARAMETERS TO LOCAL SCOPE VARIABLES:
	/////////////////////////////////////////////////////////////////////////////////////

	// const int cycle_dir  = 1;
	double T_cycle  = 2.0;
	double T_exp    = 1.0;
	double ax_x     = 0.15;
	double ax_y     = 0.08;
	double ax_ang   = 0.0;
	double sig_exp;

	double ax_x_adj = 0.0;
	double ax_y_adj = 0.0;

	/////////////////////////////////////////////////////////////////////////////////////
	// Simulation-specific parameters:
	/////////////////////////////////////////////////////////////////////////////////////

	double T_MAX  = 10.0;
	double t_ref =  0.0;

	int step_sim = 0;
	int r_i, c_i;

	/////////////////////////////////////////////////////////////////////////////////////
	// Complete kinematics set-up:
	/////////////////////////////////////////////////////////////////////////////////////

	// Trajectory path - constraint matrices:
	nml_mat* A_con = nml_mat_new(N_CONSTR_TRAJ, N_COORD_EXT);
	nml_mat* b_con = nml_mat_new(N_CONSTR_TRAJ, 1);

	sig_exp    = 3.0/T_exp;
	dt_phi_ref = 2*PI/T_cycle;

	/////////////////////////////////////////////////////////////////////////////////////
	// ITM console output:
	/////////////////////////////////////////////////////////////////////////////////////

#if USE_ITM_OUT_SIM
	printf("%f\t%f\t%f\t%f\t%f\t%f\n",
		dt_k,
		T_cycle,
		T_exp,
		ax_x,
		ax_y,
		ax_ang);
#endif

	/////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////
	// USER CODE BEGIN WHILE - GAO
	/////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////

	do {

		/////////////////////////////////////////////////////////////////////////////////////
		// Apply delay:
		/////////////////////////////////////////////////////////////////////////////////////

		HAL_Delay(25);

		/////////////////////////////////////////////////////////////////////////////////////
		// Run simulation:
		/////////////////////////////////////////////////////////////////////////////////////

		t_ref  = dt_k*step_sim;
		phi_ref = dt_phi_ref*t_ref;

		//  Adjusted trajectory path dimensions:
		ax_x_adj = (1.0 - exp(-sig_exp*t_ref))*ax_x;
		ax_y_adj = (1.0 - exp(-sig_exp*t_ref))*ax_y;

		// Generate trajectory points:
		traj_ellipse_help(phi_ref, dt_phi_ref, p_ref, dt_p_ref, u_t_ref,
				A_con, b_con,
				ax_x_adj, ax_y_adj, ax_ang);

		/////////////////////////////////////////////////////////////////////////////////////
		// Simulation output:
		/////////////////////////////////////////////////////////////////////////////////////

		// Write feedback message:
		/*
		send_lowerlimb_exercise_feedback_help(
			p_ref[IDX_X], p_ref[IDX_Y],
			0, 0,
			dt_p_ref[IDX_X], dt_p_ref[IDX_Y],
			0, 0,
			0, 0,
			0, 0, // force Sensor
			0, 0, 0, // force commands
			0, 0, // reference positions
			0, 0, // reference velocities
			0, 0 // reference phase and frequency
		);
		*/

		// ITM console output:
		printf("%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t",
			step_sim,
			t_ref,
			phi_ref,
			dt_phi_ref,
			p_ref[IDX_X],
			p_ref[IDX_Y],
			dt_p_ref[IDX_X],
			dt_p_ref[IDX_Y]);

		for (r_i = 0; r_i < N_CONSTR_TRAJ; r_i++) {
			for (c_i = 0; c_i < N_COORD_EXT; c_i++)
				printf("%f\t", A_con->data[r_i][c_i]);
			printf("\n");
		}

		/////////////////////////////////////////////////////////////////////////////////////
		// Increase step counter:
		/////////////////////////////////////////////////////////////////////////////////////

		step_sim++;

	} while (t_ref <= T_MAX);
}
