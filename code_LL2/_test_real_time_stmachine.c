/////////////////////////////////////////////////////////////////////////////
//
// _test_real_time_stmachine.c
//
// Created on: 2024.07.10
// Author: Gabriel Aguirre Ollinger
//
/////////////////////////////////////////////////////////////////////////////

#include <_test_real_time.h>

extern lowerlimb_sys_info_t lowerlimb_sys_info;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// TEST SCRIPT - REAL-TIME
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
test_real_time_stmachine(ADC_HandleTypeDef* hadc1, ADC_HandleTypeDef* hadc3) {

	///////////////////////////////////////////////////////////////////////////////
	// General settings:
	///////////////////////////////////////////////////////////////////////////////

	const uint8_t USE_SOFTWARE_MSG_LIST   = 0; // CRITICAL option (2)
	const uint8_t OVERRIDE_CMD_CODE_TESTS = 0; // CRITICAL option (3)

	///////////////////////////////////////////////////////////////////////////////
	// MOTOR STATE VARS:
	///////////////////////////////////////////////////////////////////////////////

	uint8_t motor_alert         = 0;
	/*
	uint8_t motor_torque_active = 0;
	*/

	///////////////////////////////////////////////////////////////////////////////
	// FIRMWARE / CONTROL PARAMETERS:
	///////////////////////////////////////////////////////////////////////////////

	uint64_t up_time;
	uint64_t up_time_end;

	lowerlimb_motors_settings_t LL_motors_settings;
	lowerlimb_mech_readings_t   LL_mech_readings;
	/*
	traj_ctrl_params_t          traj_ctrl_params;
	admitt_model_params_t       admitt_model_params;
	lowerlimb_ref_kinematics_t	ref_kinematics;
	*/

	///////////////////////////////////////////////////////////////////////////////
	// Real-time time step, sec:
	///////////////////////////////////////////////////////////////////////////////

	double dt_k = (double)DT_STEP_MSEC/MSEC_PER_SEC;

	///////////////////////////////////////////////////////////////////////////////
	// CALIBRATION variables:
	///////////////////////////////////////////////////////////////////////////////

	/*
	calib_traj_t calib_traj = CalibTraj_Null;
	uint8_t calib_enc_on    = 0;
	*/

	///////////////////////////////////////////////////////////////////////////////
	// HOMING variables:
	///////////////////////////////////////////////////////////////////////////////

	/*
	double OMEGA_THR_HOMING_START = 0.03;

	uint8_t homing_on      = 0; // CRITICAL initialization
	uint8_t init_home_traj = 1;
	*/

	///////////////////////////////////////////////////////////////////////////////
	// IDLE activity state variables:
	///////////////////////////////////////////////////////////////////////////////

	// uint8_t init_idle_activity_state = 1;

	///////////////////////////////////////////////////////////////////////////////
	// TCP/IP variables:
	///////////////////////////////////////////////////////////////////////////////

	int sock_status;

	// TCP communication checks:
	int32_t ret_tcp_msg      = 0;
	uint64_t dt_ret_tcp_msec = 0;

	///////////////////////////////////////////////////////////////////////////////
	// State variables:
	///////////////////////////////////////////////////////////////////////////////

	uint16_t cmd_code      = NO_CMD;
	uint16_t cmd_code_prev = NO_CMD;

	uint8_t is_valid_cmd_code = 0;

	// uint8_t  app_state;
	// uint8_t exercise_state_prev = lowerlimb_sys_info.exercise_state;

	///////////////////////////////////////////////////////////////////////////////
	// Real-time counters, timers and switches:
	///////////////////////////////////////////////////////////////////////////////

	double T_RUN_MAX   = 5000;
	double t_ref       = 0.0;

	int rt_step_i      = 0; // real-time step counter
	int r_i, c_i; // general-purpose counters

	// int8_t switch_traj = SWITCH_TRAJ_NULL;

	///////////////////////////////////////////////////////////////////////////////
	// Initialize app:
	///////////////////////////////////////////////////////////////////////////////

	lowerlimb_app_state_initialize(0, VER_H, VER_L, VER_P, &LL_motors_settings); // was app_state =

	///////////////////////////////////////////////////////////////////////////////
	// Initialize motor algorithm:
	///////////////////////////////////////////////////////////////////////////////

	init_motor_algo(&LL_mech_readings, &LL_motors_settings);

	///////////////////////////////////////////////////////////////////////////////
	// Control settings:
	///////////////////////////////////////////////////////////////////////////////

	// RESTORE

	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	// USER CODE LOOP:
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////

	while (t_ref <= T_RUN_MAX) {

		///////////////////////////////////////////////////////////////////////////////
		// Get uptime in milliseconds:
		///////////////////////////////////////////////////////////////////////////////

		up_time = getUpTime();

		///////////////////////////////////////////////////////////////////////////////
		// Execute real-time step:
		///////////////////////////////////////////////////////////////////////////////

		if (up_time >= algo_nextTime) { // RT time step

			///////////////////////////////////////////////////////////////////////////////
			// Set up next RT time point (msec):
			///////////////////////////////////////////////////////////////////////////////

			algo_nextTime = up_time + DT_STEP_MSEC;

			///////////////////////////////////////////////////////////////////////////////
			// Update reference time:
			///////////////////////////////////////////////////////////////////////////////

			t_ref = dt_k*rt_step_i;

			///////////////////////////////////////////////////////////////////////////////
			// Ethernet connection:
			///////////////////////////////////////////////////////////////////////////////

			#if USE_ITM_TCP_CHECK
				dt_ret_tcp_msec = getUpTime(); //  tests time elapsed waiting for ethernet_w5500_state() to return
			#endif

			ret_tcp_msg = ethernet_w5500_state(&sock_status);

			#if USE_ITM_TCP_CHECK
				dt_ret_tcp_msec = getUpTime() - dt_ret_tcp_msec;

				if (sock_status != SOCK_ESTABLISHED) { // (ret_tcp_msg < 0)
					// Current socket state:
					printf("ethernet_w5500_state(): SOCKET STATUS [0x%02x]\n", sock_status);

					// Current TCP return message and time:
					printf("rt_step_i [%d]: cmd_code = [%d], ret_tcp_msg = [%d], dt_ret_tcp_msec = [%d]\n\n", rt_step_i, cmd_code, ret_tcp_msg, (int)dt_ret_tcp_msec);
				}
			#endif

			//////////////////////////////////////////////////////////////////////////////////
			// Get TCP/IP message:
			//////////////////////////////////////////////////////////////////////////////////

			is_valid_cmd_code = is_valid_rcv_data_cmd_code(&cmd_code, Read_Haptic_Button(), motor_alert, USE_SOFTWARE_MSG_LIST, OVERRIDE_CMD_CODE_TESTS);

			if (is_valid_cmd_code) {
				send_OK_resp(cmd_code);

				#if USE_ITM_CMD_CHECK
					if (cmd_code != 0) {
						printf("   ======================================\n");
						if (USE_SOFTWARE_MSG_LIST)
							printf("   cmd_code(%d) [%s] \n", cmd_code, MSG_TCP_STR[cmd_code]);
						else
							printf("   cmd_code(%d) [%s] \n", cmd_code, CMD_STR[cmd_code]);
						printf(" \n");
					}
				#endif
			}

			///////////////////////////////////////////////////////////////////////////////
			// Clear motor_alert after sending it to TCP/IP APP state:
			///////////////////////////////////////////////////////////////////////////////

			motor_alert = 0;

			#if USE_ITM_OUT_GUI_PARAMS

			#endif


			// if (lowerlimb_sys_info.system_state == SYS_ON) {

				///////////////////////////////////////////////////////////////////////////////
				// Update LEDs state:
				///////////////////////////////////////////////////////////////////////////////

				cycle_haptic_buttons();

				///////////////////////////////////////////////////////////////////////////////
				// Update safety:
				///////////////////////////////////////////////////////////////////////////////

				set_safetyOff(lowerlimb_sys_info.safetyOFF);
			// }

			///////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////
			// SYSTEM STATE SWITCH:
			///////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////



			///////////////////////////////////////////////////////////////////////////////
			// Track changes of state:
			///////////////////////////////////////////////////////////////////////////////

			cmd_code_prev = cmd_code;

			///////////////////////////////////////////////////////////////////////////////
			// ITM console output:
			///////////////////////////////////////////////////////////////////////////////

			#if USE_ITM_OUT_RT_CHECK_LONG
				if (rt_step_i % (DT_DISP_MSEC_REALTIME/DT_STEP_MSEC) == 0) {

					// Check uptime after computations:
					up_time_end = getUpTime();

					if ((up_time_end - up_time) > DT_STEP_MSEC) {
						printf("\n");
						printf("   rt_step_i = [%d], rt_step_i = [%3.3f], D_up_time = [%d] \n",
							rt_step_i,
							t_ref,
							(int)up_time_end - (int)up_time);

						printf("   cmd_code_prev = [%s], cmd_code = [%s] \n",
									MSG_TCP_STR[cmd_code_prev], MSG_TCP_STR[cmd_code]);
						printf("   lowerlimb_sys_info.activity_state = [%s] \n\n",   ACTIV_STATE_STR[lowerlimb_sys_info.activity_state]);
					}
				}
			#endif

			///////////////////////////////////////////////////////////////////////////////
			// Increase real-time step counter:
			///////////////////////////////////////////////////////////////////////////////

			rt_step_i++;

		} // end if (up_time >= algo_nextTime) // RT time step
	} // end while (t_ref <= T_RUN_MAX)
}
